<h5>Task</h5>
<ol>
<li>Создать любой gradle проект.</li>
<li>Придерживаться GitFlow: master -> develop -> feature/fix.</li>
<li>Создать два класса:
<p>a) Клиент - имеет список данных в виде List&lt;Integer&gt; от 1 до n.  Отдельными потоками, 
по случайному индексу из списка выбирается значение (метод remove()) и в виде запроса 
(класс с int -полем), содержащего это значение, отправляется на сервер в асинхронном режиме 
(например отправляются со случайной задержкой между запросами - диапазон - от 100 до 500 мс). 
Количество запросов равно размеру первоначального списка. 
Контроль: после отправки всех запросов размер списка данных = 0.</p>
<p>b) Сервер - получает запросы от клиента. Метод обрабатывающий запрос имеет задержку 
в виде рандомного инта. Диапазон - от 100 до 1000 мс. Сервер обрабатывает запросы, используя 
общий для всех потоков ресурс: List&lt;Integer&gt;, в который складываются значения приходящие 
с запросом. В ответ от сервера передаем размер листа на момент формирования ответа (класс 
с int-полем). Итоговый контроль правильности данных на стороне сервера: список (общий ресурс) 
должен содержать значения от 1 до n без пробелов, повторений, размерность его должна 
составлять n.</p></li>
<li>Клиент получает от сервера ответ и в общий для всех потоков ресурс accumulator суммирует 
значение из ответа от сервера. Итоговый контроль: accumulator = (1+n) * (n/2). Т.е. для 
диапазона 1-100 ответ должен быть 5050.</li>
<li>Протестировать эти два класса с проверкой многопоточности.</li>
<li>Протестировать взаимодействие клиента - сервера отдельным тестом (интеграционный) - 
обязательно.</li>
<li>В реализации использовать классы пакета java.util.concurrent (обязательно Lock, Callable, 
Executor, Future, остальное - по выбору).</li>
<li>Методы класса Object (относящиеся к потокам и монитору) и ключевое слово synchronized НЕ использовать.</li>
</ol>
